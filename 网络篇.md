> 网络篇应该是重点关注的部分，优先级甚至大于CSS部分。该部分前端主要关注的有：http、缓存、网络安全，状态码等

### GET与POST的区别？

关于这个题目，曾经有一篇文章一度很火：[99%的人都理解错了HTTP中GET与POST的区别](https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd)，后来剧情反转，知乎出现一篇：[听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？](https://zhuanlan.zhihu.com/p/25028045)

下面引用w3schools的解答：

GET 方法

- 可被缓存
- 保留在浏览器历史记录中
- 可被收藏为书签
- 不应在处理敏感数据时使用
- 有长度限制
- 只应当用于取回数据

POST 方法

- 不会被缓存
- 不会保留在浏览器历史记录中
- 不能被收藏为书签
- 对数据长度没有要求

### 怎么处理跨域？

跨域的处理主要有下面几种方式：

- jsonp跨域
- document.domain + iframe跨域
- location.hash + iframe跨域
- window.name + iframe跨域
- postMessage跨域
- 跨域资源共享（CORS）
- nginx代理跨域
- Nodejs中间件代理跨域
- WebSocket协议跨域

基本使用与分析可以参考：[前端常见跨域解决方案（全）](https://segmentfault.com/a/1190000011145364)

### 在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么？

这个题目好像是必考题了，大神可以讲几天，推荐这篇文章：[从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://fex.baidu.com/blog/2014/05/what-happen/ "从输入 URL 到页面加载完成的过程中都发生了什么事情？")

从网上找到的简答版本如下：

1. 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
2. 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;
3. 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;
4. 进行HTTP协议会话，客户端发送报头(请求报头);
5. 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
6. 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
7. 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;
8. 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;
9. 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;
10. 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成

### 浏览器缓存

浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：

- 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
- 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
- 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；
- 区别是，强缓存不对发送请求到服务器，但协商缓存会。
- 当协商缓存也没命中时，服务器就会将资源发送回客户端。
- 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
- 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；

**强缓存**

- Cache-Control中的max-age保存一个相对时间。表示浏览器接收到文件之后，缓存在相对应的时间内均有效。如果同时存在cache-control和Expires,浏览器优先使用cache-control
- Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没有失效就直接用缓存文件。该方法有一个问题，服务器可能和客户端时间不一致，因此该字段很少使用

**协商缓存**

- last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新时间。下次浏览器请求资源时就发送if-modified-since字段。服务器用本地last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新的资源给浏览器，如果时间一致则返回304状态码，让浏览器继续使用缓存
- Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否变化，如果变化返回新资源，否则返回304

### 域名解析

1. 首先浏览器会先查找本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。
2. 如果没有找到则会查找本地的DNS解析器缓存，如果找到则返回。
3. 如果还是没有找到则会查找本地DNS服务器，如果找到则返回。
4. 最后迭代查询，按根域服务器->顶级域名.cn->第二层域名->子域名的顺序找到IP地址

### TCP的3次握手

首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。

1. 客户机的TCP先向服务器的TCP发送一个连接请求报文. 这个特殊的报文中不含应用层数据, 其首部中的SYN标志位被置另外, 客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据,但要消耗掉一个序号)
2. 服务器端的TCP收到连接请求报文后, 若同意建立连接, 就向客户机发送请求, 并为该TCP连接分配TCP缓存和变量. 在确认报文中,SYN和ACK位都被置为1, 确认号字段的值为x+1, 并且服务器随机产生起始序号seq=y(确认报文不携带数据, 但也要消耗掉一个序号). 确认报文同样不包含应用层数据.
3. 当客户机收到确认报文后, 还要向服务器给出确认, 并且也要给该连接分配缓存和变量. 这个报文的ACK标志位被置为1, 序号字段为x+1, 确认号字段为y+1

### TCP的四次挥手

1. 客户机打算关闭连接,就向其TCP发送一个连接释放报文,并停止再发送数据,主动关闭TCP连接, 该报文的FIN标志位被置1, seq=u, 它等于前面已经传送过的数据的最后一个字节的序号加1(FIN报文即使不携带数据,也要消耗掉一个序号)
2. 服务器接收连接释放报文后即发出确认, 确认号是ack=u+1, 这个报文自己的序号是v, 等于它前面已传送过的数据的最后一个自己的序号加此时, 从客户机到服务器这个方向的连接就释放了, TCP连接处于半关闭状态. 但服务器若发送数据, 客户机仍要接收, 即从服务器到客户机的连接仍未关闭.
3. 若服务器已经没有了要向客户机发送的数据, 就通知TCP释放连接, 此时其发出FIN=1的连接释放报文
4. 客户机收到连接释放报文后, 必须发出确认. 在确认报文中, ACK字段被置为1, 确认号ack=w+1, 序号seq=u+此时, TCP连接还没有释放掉, 必须经过等待计时器设置的时间2MSL后, A才进入到连接关闭状态.

### 状态码

状态码主要包括以下部分：

- 1xx：指示信息-表示请求已接收，继续处理
- 2xx：成功-表示请求已被成功接收，理解，接收
- 3xx：重定向-要完成请求必须进行更进一步的操作
- 4xx：客户端错误-请求语法错误或请求无法实现
- 5xx：服务器端错误：服务器未能合法实现请求

